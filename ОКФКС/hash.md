Алгоритмы хэш-функций используют математические и логические операции для преобразования входных данных в фиксированное значение (хэш). Хотя детали зависят от конкретного алгоритма, большинство хэш-функций работают по схожему принципу. Рассмотрим основные шаги и подходы, которые лежат в основе таких алгоритмов.

---

### Общие этапы работы алгоритма хэш-функции:
1. **Предварительная обработка данных**
   - **Выравнивание данных (padding)**  
     Если длина входных данных не кратна блоку, алгоритм добавляет дополнительные биты (например, дополняя до ближайшего размера, кратного 512 битам).
   - **Разделение на блоки**  
     Данные разбиваются на равные части (например, блоки по 512 бит), которые обрабатываются последовательно.

2. **Инициализация начального состояния**  
   Алгоритм задает начальные значения, которые будут использоваться в процессе. Например, в SHA-256 это 256-битные константы.

3. **Обработка каждого блока**  
   Каждый блок данных преобразуется через серию математических операций:
   - **Побитовые операции**: AND, OR, XOR, сдвиги.
   - **Модульная арифметика**: сложение по модулю $2^{32}$ или $2^{64}$.
   - **Функции смешивания**: операции, которые обеспечивают перемешивание данных для равномерного распределения хэшей.

4. **Комбинирование блоков**  
   Каждый обработанный блок влияет на текущее состояние (чаще всего через побитовые операции и сложение). Итоговое состояние после обработки всех блоков становится хэш-суммой.

5. **Вывод результата**  
   После обработки всех данных итоговое состояние алгоритма (хэш) представляется в виде строки фиксированной длины.

---

### Особенности некоторых популярных алгоритмов
#### **MD5 (Message Digest 5)**
1. Разделяет данные на блоки по 512 бит.
2. Инициализирует 128-битное начальное состояние.
3. Выполняет 64 итерации над каждым блоком, используя четыре нелинейные функции и добавляя заранее определенные константы.
4. После обработки всех блоков выдает 128-битный хэш.

#### **SHA-256 (Secure Hash Algorithm 256)**
1. Делит данные на 512-битные блоки.
2. Использует 256-битное начальное состояние, состоящее из восьми констант.
3. Для каждого блока выполняет 64 шага, используя сложные функции, такие как побитовые сдвиги, логические операции и предварительно вычисленные константы.
4. Итоговый хэш — 256 бит (32 байта).

#### **MurmurHash**
1. Применяется для хэш-таблиц, а не для криптографии.
2. Делит данные на блоки фиксированного размера.
3. Использует операции XOR, умножение на заранее определенные константы и побитовые сдвиги для обеспечения хорошего распределения.
4. Быстрый, но неустойчив к криптографическим атакам.

---

### Пример простого алгоритма хэш-функции
Вот пример упрощенного алгоритма хэширования, чтобы показать базовые принципы:

```python
def simple_hash(data):
    hash_value = 0
    for char in data:
        # Используем код символа и простой сдвиг
        hash_value = (hash_value * 31 + ord(char)) % (2**32)
    return hash_value

# Пример
print(simple_hash("hello"))  # Вывод: хэш-значение
```

Этот пример:
- Берет символ строки,
- Преобразует его в числовое представление (код символа),
- Смешивает результат через умножение, сложение и взятие по модулю.

---

### Принципы безопасности хэш-функций
Для криптографических алгоритмов важны следующие свойства:
1. **Необратимость**: невозможно восстановить оригинальные данные по хэшу.
2. **Устойчивость к коллизиям**: найти два разных входа с одинаковым хэшем должно быть сложно.
3. **Чувствительность к изменениям**: небольшое изменение входных данных приводит к значительному изменению хэша.

Эти свойства обеспечиваются через сложные функции и обработку данных в несколько этапов.

Необратимость хэш-функций обеспечивается рядом математических и алгоритмических принципов. Они направлены на то, чтобы сделать процесс вычисления хэша односторонним, то есть сложным (или практически невозможным) для обратного восстановления исходных данных. Рассмотрим основные факторы, которые обеспечивают необратимость.

---

### 1. **Потеря информации**  
Хэш-функции преобразуют входные данные произвольной длины в строку фиксированной длины (например, 256 бит для SHA-256).  
- **Сжатие**: При преобразовании данных их размер уменьшается, что неизбежно приводит к потере информации. Многие различные входные значения могут иметь одинаковый хэш (коллизии), но определить, какое из них было оригиналом, невозможно.
- **Пример**: Если хэш равен $X$, может существовать множество комбинаций входных данных, которые также дают $X$.

---

### 2. **Сложность функций преобразования**
Современные хэш-функции используют нелинейные и сложные математические операции:
- **Побитовые операции** (AND, OR, XOR): смешивают данные на уровне отдельных бит.
- **Сдвиги и циклические повороты**: меняют порядок битов, увеличивая сложность восстановления.
- **Модульная арифметика**: добавляет нелинейность, например, сложение по модулю $2^{32}$ или $2^{64}$.
- **Нелинейные функции**: включают использование таблиц замен (S-boxes) или сложных математических формул.

Эти операции делают восстановление исходных данных без знания всего алгоритма практически невозможным.

---

### 3. **Хаотичность и лавинный эффект**
- **Лавинный эффект**: Небольшое изменение во входных данных (например, изменение одного бита) приводит к значительному изменению хэша. Это делает восстановление исходного значения или предсказание хэша для схожих данных крайне сложным.
- **Пример**:  
  ```plaintext
  SHA-256("hello") = 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
  SHA-256("Hello") = 185f8db32271fe25f561a6fc938b2e264306ec304eda518007d1764826381969
  ```

---

### 4. **Применение раундов и итераций**
Алгоритмы, такие как SHA-256, применяют обработку данных в несколько этапов (раундов), используя разные константы и преобразования. Каждый раунд добавляет уровень сложности и защищает хэш от обратного вычисления.

---

### 5. **Использование случайности (константы и соль)**
- Многие криптографические хэш-функции используют заранее определенные константы (например, корни простых чисел в SHA-256), что усложняет предсказание результата.
- **Соль**: Для защиты паролей добавляется случайная строка (соль), которая смешивается с данными перед хэшированием. Это делает хэши для одинаковых данных уникальными, даже если данные повторяются.

---

### 6. **Экспоненциальная сложность обратного поиска**
- Для нахождения оригинального входа из хэша приходится перебирать все возможные комбинации входных данных (атака "грубой силы").
- Если длина хэша составляет 256 бит (как в SHA-256), то возможное количество хэшей равно $2^{256}$. Перебрать такое количество значений физически невозможно, даже при использовании самых мощных современных суперкомпьютеров.

---

### Пример: почему хэш необратим
Возьмем функцию:
```math
 H(x) = (x \cdot 123 + 456) \mod 1000 
```
Если хэш-значение равно $789$, найти $x$, приведший к этому значению, можно лишь методом перебора. Однако, в реальных криптографических хэш-функциях используются значительно более сложные операции, а их обратное вычисление требует огромных вычислительных ресурсов.

---

### Вывод
Необратимость хэш-функций обеспечивается:
1. Сжатием данных и потерей информации.
2. Сложностью и нелинейностью используемых операций.
3. Лавинным эффектом и хаотичностью.
4. Многоэтапной обработкой данных (раундами).
5. Огромной вычислительной сложностью для обратного восстановления.

Эти принципы делают современные криптографические хэш-функции (SHA-256, SHA-3) практически необратимыми.