# Лекция: Стандартная библиотека C++

## Введение в стандартную библиотеку C++

Стандартная библиотека C++ (STL - Standard Template Library) предоставляет набор готовых инструментов для эффективной разработки программ. Это набор классов и функций, которые упрощают разработку, устраняя необходимость писать базовые алгоритмы и структуры данных с нуля. STL делится на несколько ключевых компонентов, таких как контейнеры, итераторы, алгоритмы и функции работы с потоками. 

### Основные компоненты стандартной библиотеки C++

1. **Контейнеры** – классы для хранения и управления коллекциями объектов.
2. **Итераторы** – объекты, которые позволяют перебирать элементы контейнеров.
3. **Алгоритмы** – функции для выполнения операций с контейнерами, таких как сортировка, поиск, копирование и модификация данных.
4. **Функции работы с потоками** – классы для работы с файлами и вводом/выводом.

---

## Контейнеры

Контейнеры — это объекты, которые позволяют сохранять другие объекты в определённом порядке. В STL существует несколько типов контейнеров.

### Основные контейнеры STL:

1. **`std::vector`** – динамический массив.
   - Позволяет добавлять элементы в конец.
   - Имеет доступ по индексу.
   - Пример:
     ```cpp
     #include <vector>
     #include <iostream>
     
     int main() {
         std::vector<int> numbers = {1, 2, 3, 4};
         numbers.push_back(5);  // Добавляем элемент в конец
         std::cout << "Последний элемент: " << numbers.back() << std::endl;
         return 0;
     }
     ```

2. **`std::list`** – двусвязный список.
   - Эффективно вставляет и удаляет элементы на концах.
   - Не имеет доступа по индексу, требует последовательного перебора.
   - Пример:
     ```cpp
     #include <list>
     #include <iostream>
     
     int main() {
         std::list<int> numbers = {1, 2, 3, 4};
         numbers.push_front(0);  // Добавляем элемент в начало
         for (int num : numbers) {
             std::cout << num << " ";
         }
         return 0;
     }
     ```

3. **`std::deque`** – двухсторонняя очередь.
   - Позволяет добавлять элементы как в начало, так и в конец.
   - Пример:
     ```cpp
     #include <deque>
     #include <iostream>
     
     int main() {
         std::deque<int> d = {2, 3};
         d.push_front(1);  // Добавляем в начало
         d.push_back(4);   // Добавляем в конец
         for (int num : d) {
             std::cout << num << " ";
         }
         return 0;
     }
     ```

4. **`std::set`** – множество.
   - Хранит уникальные элементы.
   - Автоматически сортирует элементы.
   - Пример:
     ```cpp
     #include <set>
     #include <iostream>
     
     int main() {
         std::set<int> s = {3, 1, 4, 1, 2};
         for (int num : s) {
             std::cout << num << " ";  // Вывод: 1 2 3 4
         }
         return 0;
     }
     ```

5. **`std::map`** – ассоциативный массив.
   - Хранит пары «ключ-значение».
   - Пример:
     ```cpp
     #include <map>
     #include <iostream>
     
     int main() {
         std::map<int, std::string> m;
         m[1] = "один";
         m[2] = "два";
         for (const auto& pair : m) {
             std::cout << pair.first << ": " << pair.second << std::endl;
         }
         return 0;
     }
     ```

---

## Итераторы

Итераторы — это объекты, которые позволяют перебирать элементы контейнеров. Они действуют как указатели, позволяя манипулировать элементами контейнера, не зная, как данные организованы внутри.

Пример использования итераторов с контейнером `std::vector`:
```cpp
#include <vector>
#include <iostream>

int main() {
    std::vector<int> vec = {1, 2, 3, 4, 5};
    std::vector<int>::iterator it;
    
    for (it = vec.begin(); it != vec.end(); ++it) {
        std::cout << *it << " ";
    }
    return 0;
}
```

### Виды итераторов:

1. **Input итераторы** – только чтение данных (например, в потоках).
2. **Output итераторы** – только запись данных.
3. **Forward итераторы** – однонаправленные, могут выполнять чтение и запись.
4. **Bidirectional итераторы** – двунаправленные, могут перемещаться как вперед, так и назад.
5. **Random Access итераторы** – могут перемещаться на произвольное расстояние (например, итераторы для `std::vector`).

---

## Алгоритмы

STL предоставляет множество алгоритмов, которые работают с контейнерами через итераторы. Эти алгоритмы позволяют сортировать, искать, копировать элементы и многое другое.

Пример: сортировка элементов в `std::vector` с использованием алгоритма `std::sort`:
```cpp
#include <vector>
#include <algorithm>
#include <iostream>

int main() {
    std::vector<int> vec = {4, 1, 3, 5, 2};
    std::sort(vec.begin(), vec.end());  // Сортировка элементов в порядке возрастания
    
    for (int num : vec) {
        std::cout << num << " ";  // Вывод: 1 2 3 4 5
    }
    return 0;
}
```

### Полезные алгоритмы:

1. **`std::sort`** – сортировка диапазона.
2. **`std::find`** – поиск элемента.
3. **`std::copy`** – копирование элементов из одного контейнера в другой.
4. **`std::for_each`** – применение функции ко всем элементам.
5. **`std::transform`** – преобразование элементов и сохранение результатов.

---

## Ввод и вывод

Для работы с потоками (ввод и вывод данных) используется стандартный набор функций из `<iostream>` и `<fstream>`.

### Основные функции:

1. **`std::cin`** – стандартный ввод.
2. **`std::cout`** – стандартный вывод.
3. **`std::cerr`** – вывод ошибок.
4. **`std::ifstream`** – чтение данных из файла.
5. **`std::ofstream`** – запись данных в файл.

Пример чтения и записи в файл:
```cpp
#include <fstream>
#include <iostream>

int main() {
    std::ofstream outFile("example.txt");
    outFile << "Hello, file!" << std::endl;
    outFile.close();

    std::ifstream inFile("example.txt");
    std::string content;
    std::getline(inFile, content);
    std::cout << "Содержимое файла: " << content << std::endl;
    inFile.close();

    return 0;
}
```

---

## Заключение

Стандартная библиотека C++ — это мощный инструмент, который помогает программистам избегать написания рутинного кода. Благодаря контейнерам, итераторам и алгоритмам, вы можете сосредоточиться на решении основной задачи, а не на реализации базовых структур данных и операций.
